---
title: "Introduction to GUS-LD"
author: "Timothy P. Bilton"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include = FALSE}
knitr::opts_chunk$set( collapse = TRUE, comment = "#>", eval=TRUE)
library(GUSLD)
```

This tutorial is an introduction to GUSLD. GUSLD is an R package for estimating linkage disequilibrium (LD) using read count data generated from high-throughput sequencing technology. The methodology underpinning GUSLD is described by ?. Some important aspects of GUSLD are:
* GUSLD expects the user to filter SNPs based on low read depth.  

GUSLD accounts for genotyping errors in the form of sequencing errors and heterozygous genotypes called as homozygous ue to low sequencing depth. Consequently, GUSLD expects the user to not filter SNPs based on low read depth or setting genotype calls to missing the read depth is below some threshold value. 
* 

For this tutorial, we will use a dataset consisting of 704 individuals (species is deer) and 38 SNPs genotyped using genotyping-by-sequencing (GBS). This data accompines the GUSLD pacakge and is stored as a Variant Call Format (VCF) file. The filename to the VCF file can be obtained using the `deerData()` function.
```{r simDS, eval = T}
vcffile <- deerData() # extract filename
vcffile               # filename stored in object vcffile
```

## Loading Sequencing Data 

GUSLD uses the functionality available in the GUSbase package to read in data. At present, data stored in a Variant Call Format (VCF) file can be used in GUSLD, provided that there is some form of allelic depth information (e.g., the number of reads for the reference and alternate alleles). The `VCFtoRA` function reads data from a a VCF file and converts it into what we call a reference/alternate (RA) file.

```{r loadData, eval=T}
# convert VCF file to an RA file
rafile <- VCFtoRA(infilename = vcffile, direct = "./")
```

The important arguments of the `VCFtoRA` function are:

1. `infilename`: The name of the VCF file to be converted to RA format. 
2. `direct`: Specifies which directory to write the RA file to (relative to the current working directory).

Currently, `VCFtoRA` requires one of the fields **AD**, **AO and RO**, or **DP4** to be present in the VCF file to extract allelic depth information. One other thing to note is that `VCFtoRA` returns the file location of the created RA file.
```{r rafile, eval=T}
rafile # file path of RA file
```

The RA file created is a tab-delimited file with columns, **CHROM** (the chromosome name taken from the "#CHROM" column in the VCF file), **POS** (the position of the SNP taken from the "POS" column in the VCF file), and **SAMPLES** which consists of the sampleIDs used in the VCF (columns 10 and above in the VCF file). For example, the first five columns and first four rows of the RA file for the deer dataset are:

|CHROM	|POS	   |Sample1  |Sample2 |Sample3 |
|:------|:-------|:--------|:-------|:-------|
|SNP1	  |1    	 |0,6      |0,11    |0,3     |
|SNP2	  |2       |7,0      |5,0     |8,0     |
|SNP3	  |3       |2,4      |1,1     |0,5     |
|SNP4	  |4       |4,0      |15,0    |12,0    |

The entry in the second row and the third column is "7,0" which means that 7 reads for the reference allele have been observed and none for the alternate allele. In addition, the third row of the third column is "2,4" which means that 2 reads for the reference allele and 4 reads for the alternate allele have been observed at the SNP on chromosome SNP3 and position 3 in individual Sample1. Note: for this data, SNP calling was performed *de novo* and so each SNP have been given an arbitary chromosome number and position. For SNPs called via a reference assembly, the chromosome and position columns will correspond to the chromosome and position of the reference assembly at which the SNP was called. 

At this point, one may ask why not read in sqeucning data from a VCF file directly into R? One reason for converting VCF data to RA format is that the size of the dataset is greatly reduced (since only the read counts are retained and the additional information contained in the VCF file is discard). This makes it quicker to read data into R and is espcially useful for when one only wants to read in a subset of the data.

An RA file can then be loaded into R using the `readRA` function.
```{r readRA, eval=T}
RAdata <- readRA(rafile = rafile, sampthres = 0.01, excsamp = NULL)
```

The arguments of the `readRA` function are:

1. `rafile`: Name of the RA file to be read in.
2. `sampthres`: Specifies the minimum sample depth of an individual before it is removed. This is a filtering step used for removing samples that do not have enough data to be practically useful.
3. `excsamp`: Specifies IDs of any samples in the RA data set to be discarded (for problematic samples to be removed). The input for `excsamp` must correspond to the sample IDs in the RA file.

The RA data is now stored as an `RA` object.
```{r class_RAdata, eval=T}
class(RAdata)
```

Summary information of the RA object can be displayed by printing the object.
```{r RAdata, eval=T}
RAdata
```

## Creating Unrelated Population


```{r makeUR, eval=T}
makeUR(RAobj=RAdata, filter = list(MAF = 0.01, MISS = 0.5, MAXDEPTH = 500),
       nClust = 2)
```


In addition to creating a unrelated population, the `makeUR` performs two additional tasks:
* Estimates the allele frequecies and the sequencing error for each SNP.
* Filters SNPs based on the following criteria
   1. `MAF`: Discard SNPs with a MAF below the threshold value (default is 0.01). Note: the MAF used corresponds to what was calculated in the previous step
   2. `MISS`: Discard SNPs where the proportion of individuals without a read (e.g., missing genotype) is greater than the threshold value (default is 0.5 (or 50%)).
   3. `MAXDEPTH`: Discard SNPs with a mean read depth above the threshold value (default is 500). This filter is available as SNPs with extremely high read depth tend to be repetivity regions which cause problems in the analysis.


can read in data stored in a Variant Call Format (VCF) file, provided that there is some form of allelic depth information (e.g., the number of reads for the reference and alternate alleles). This is done using the `VCFtoRA` function which takes in the name of a VCF file and converts it into what we call a reference/alternate (RA) file.

```{r loadData, eval=T}
# convert VCF file to an RA file
rafile <- VCFtoRA(infilename = vcffile$vcf, direct = "./", makePed=TRUE)
```


## Estimating Linkage Disequilibrium



```{r allSNPs, eval=T}
LDres <- GUSLD(urpop)
```

Alternatively, one can also write the LD results to a file instead
```{r allSNPs_file, eval=T}
LDres <- GUSLD(urpop, filename="LD_deer")
```

The 

### Set of pairwise LD

```{r subet, eval=T}
LDres <- GUSLD(urpop)
```

Again, one could write the LD results to a file by specifying `filename`.


### Specifying the LD Measures





In additional, one can specify their own LD measure provided it is a function of the disequilibrium coefficient and the allele frequencies. For example, one alternative LD measure is the correlation coefficient defined as
$$ r = \frac{D}{\sqrt{p_{A_1}(1-p_{A_1})p_{A_2}(1-p_{A_2})}} $$
```{r LD_r, eval=T}
## Define the correlation coefficient
LD_r <- function(pA1,pA2,D){
return( D/sqrt((prod(c(pA1,pA2,1-c(pA1,pA2))))) )
}
``` 
Note the the arguments for the correlation coefficient must be $D$ and $p_{A_1}$ and $p_{A_2}$. Then in GUSLD, estimation of $r$ for all SNP pairs in the deer dataset can be achieved using the following code
```{r LDmes_r, eval=T}
LDres <- GUSLD(urpop, LDmeasure = "LD_r")
```




## Final Comments

GUSLD is under contoiunous development. The author welcomes suggests for improvement and is open to contributions (via pull requests in GitHUb), provided that these fit with the favour of the package. 
